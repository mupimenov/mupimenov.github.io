
<!doctype html>
<html>
  <head>
  <meta charset="utf-8">
  <meta content="" name="description">
  <meta content="Пименов Михаил" name="author">
  <title>scon.pro</title>
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/default.css" rel="stylesheet">
  <link href="/atom.xml" rel="alternate" title="scon.pro" type="application/atom+xml">
  <link href="/stylesheets/syntax.css" type="text/css" rel="stylesheet" />
</head>
  <body>
    <header>
      <nav>
        <h3>
          <a href="/">Блог</a>
          <a href="/blog/archives">Архивы</a>
          <a href="/about">О</a>
        </h3>
      </nav>
    </header>
    


<section>
  <header>
    <time datetime="2016-05-16T10:11:08+03:00">16.05.2016</time>
    <h1><a href="/blog/2016/05/16/c-plus-plus-questions-part-2/">Вопросы по C++ (часть 2)</a></h1>
  </header>
  <article>
    <p>Вторая часть ответов на <a href="http://www.mycplus.com/featured-articles/50-c-plus-plus-interview-questions/">интервью-вопросы</a> на знание языка программирования C++.</p>

<p><strong>26) Что такое инкапсуляция</strong></p>

<p>Инкапсуляцией называют скрытие деталей реализации внутри класса. При использовании механизма инкапсуляции объекты защищаются от произвольного изменения (с помощью ключевых слов protected или private); взаимодействие с объектом происходит с помощью публичных функций-членов.</p>

<p><strong>27) Что такое перегрузка функций?</strong></p>

<p>С помощью перегрузки имеется возможность определять функции, имеющие одно и то же имя, но разный набор аргументов и/или возвращающие разные результаты.</p>

<p><strong>28) Что такое множественное наследование?</strong></p>

<p>Множественное наследование позволяет определить производный класс, который будет наследовать члены от нескольких базовых классов.</p>

<p><strong>29) Что такое перегрузка операторов?</strong></p>

<p>Аналогично перегрузке функций это возможность ЯП определить поведение оператора, при передаче ему разных аргументов.</p>

<p><strong>30) Что такое частичная специализация шаблона?</strong></p>

<p>Частичная специализация шаблона позволяет явно задать параметры основного шаблона и доопределить полученный шаблон в соответствие с его назначением.</p>

<p><strong>31) Что такое полиморфизм?</strong></p>

<p>Свойство языка, позволяющая определить разное поведение для объектов с одинаковой спецификацией.</p>

<p>Пример 1: производный класс наследует публичный интерфейс базового класса, но с помощью перекрытия изменяет поведение виртуальных функций.</p>

<p>Пример 2: перегрузка функций.</p>

<p><strong>32) В чём разница между передачей аргумента по значению и передачей аргумента по ссылке?</strong></p>

<p>В способе размещения аргумента в памяти. При передаче аргумента по значение он копируется в стек, а вызываемая функция работает с копией аргумента.
При передаче аргумента по ссылке вызываемая функция работает с исходным аргументом, а не его копией (ссылка является псевдонимом переменной).</p>

<p><strong>33) Какая разница между объектом и классом?</strong></p>

<p>Класс является сложным типом, который описывает внутренние данные и функциональный интерфейс. Объект является экземпляром класса, размещаемым в памяти.</p>

<p><strong>34) В чём разница между объявлением и определением функции?</strong></p>

<p>В объявлении указывается формат вызова, в который входят 1) имя функции, 2) описание аргументов, передаваемых в функцию, и 3) описание возвращаемого функцией результата.
В определении реализуется алгоритм работы функции.</p>

<p><strong>35) -</strong></p>

<p><strong>36) В чём разница между delete и delete[]?</strong></p>

<p>Ключевое слово delete используется для удаления объекта, которое происходит в два этапа. Во-первых, вызывается деструктор объекта, который, например, выполняет удаление членов класса. Во-вторых, выполняется освобождение занимаемой объектом памяти.
Ключевое слово delete[] используется для удаления массива объектов, при этом для каждого элемента массива будет вызван деструктор, а затем произойдёт освобождение памяти.</p>

<p><strong>37) Какая разница между вложенным (внутренним) классом и абстрактным классом?</strong></p>

<p>Внутренний класс - это класс, который определён внутри другого класса.
Абстрактный класс - это класс, имеющий чисто виртуальные функции-члены.</p>

<p><strong>38) В чём разница между перманентным и неперманентным объектом?</strong></p>

<p>Перманентный объект сохраняет своё состояние на всём протяжении жизни, в то время как неперманентный объект может изменить своё состояние.</p>

<p><strong>39) Чем отличается структура (struct) от объединения (union)?</strong></p>

<p>Объединение отличается от структуры способом размещения данных-членов. В объединении данные-члены делят отводимую для них область памяти так, что перекрывают друг друга.
В структуре (равно как и в классе) данные-члены размещаются в своих областях памяти.</p>

<p><strong>40) Чем отличается поверхностное копирование от глубокого копирования?</strong></p>

<p>При поверхностном копировании будет, например, продублирован указатель на данные (появится новый объект, который ссылается на существующие данные). При глубоком копировании вместо сохранения указателя будет осуществляться полное копирование данных.</p>

<p><strong>41) Какая разница между открытыми, защищёнными и закрытыми членами класса?</strong></p>

<p>Разница заключается в уровнях доступа к этим членам.
Открытые члены класса доступны всем. Защищённые доступны только данному классу и классам-наследникам. Закрытые члены доступны только данному классу.</p>

<p><strong>42) Какую максимальную длину может иметь массив?</strong></p>

<p>Это зависит от нескольких факторов. Во-первых, от способа размещения массива. При размещении на стеке размер зависит от размера стека (и его способности к расширению). При размещении в куче - от возможностей аппаратных средств и ОС. Во-вторых, размер должен укладываться в size_t, который зависит от используемой платформы (32 или 64 разряда).</p>

<p><strong>43) Как наиболее эффективно инвертировать связный список?</strong></p>

<p>Перейти в конец списка и двигаясь к началу менять местами указатели на следующий и предыдущий элементы списка.</p>

<p><strong>44) Какой размер у пустого класса?</strong></p>

<p>Размер пустого класса должен по крайней мере быть равен размеру минимально адресуемой области памяти. Обычно это 1 байт.</p>

<p><strong>45) Зачем используется виртуальный деструктор?</strong></p>

<p>Это единственный способ обеспечить вызов деструктора у производного класса при удалении объекта по указателю на базовый класс.</p>

<p><strong>46) Что такое виртуальный класс? Что такое дружественный класс?</strong></p>

<p>Виртуальный класс - это класс, имеющий виртуальные функции-члены.
Дружественный класс - это класс, который имеет доступ к закрытым членам данного класса.</p>

<p><strong>47. Назовите лучший способ объявить и определить глобальную переменную.</strong>
Вариант 1 (C-style):</p>

<pre>
// source.c
int global = 0;
// source.h
extern int global;
</pre>


<p>Вариант 2 (С++ style): определить класс с открытой статической переменной:</p>

<pre>
// source.hpp
class A {public: static int global;};
// source.cpp
int A::global = 0;
</pre>


<p><strong>48) В какой области памяти инстанцируется объект?</strong></p>

<p>Зависит от способа размещения. Если объект является локальной переменной, то он размещается в стеке. Если объект создаётся с использованием ключевого слова new, то он размещается в куче.</p>

<p><strong>49) В какой области памяти инстанцируется структура?</strong></p>

<p>Аналогично объекту (см. ответ на вопрос 48).</p>

<p><strong>50) Почему первый элемент массива имеет индекс 0?</strong></p>

<p>Индекс массива определяет смещение относительно начала массива. Очевидно, что по смещению 0 находится первый элемент.</p>

    
    
  </article>
</section>


<section>
  <header>
    <time datetime="2015-08-16T10:09:18+03:00">16.08.2015</time>
    <h1><a href="/blog/2015/08/16/c-plus-plus-questions-part-1/">Вопросы по С++ (часть 1)</a></h1>
  </header>
  <article>
    <p>Первая часть моих ответов на вопросы из <a href="http://www.mycplus.com/featured-articles/50-c-plus-plus-interview-questions/">списка</a>.</p>

<p><strong>1) Как определить, что связный список является кольцевым?</strong></p>

<p>Запомнить указатель (итератор) на первый элемент списка. Начать обход списка от первого элемента к последнему. Если в процессе обхода текущий указатель равен указателю на первый элемент списка, то список кольцевой. Если список пройден - список не является кольцевым.</p>

<p><strong>2) Какой целочисленный тип использовать?</strong></p>

<p>Это определяется прикладной задачей, решаемой в рамках данной предметной области. Во-первых, нужно определиться с шириной коридора принимаемых значений переменной целочисленного типа (char, short, int, long, long long; с использованием модификаторов signed, unsigned). Во-вторых, учесть количество памяти, отводимое под переменную соответствующего типа (1, 2, 4 или 8 байт).</p>

<p><strong>3) Каково отличие между конструктором и деструктором.</strong></p>

<p>Конструктор - специальный метод объекта, вызываемый сразу после выделения ему памяти, выполняющий инициализацию членов объекта. Деструктор - метод вызываемый перед освобождением памяти, отводимой объекту, служащий для &ldquo;деинициализации&rdquo; (например, удаления) членов объекта.</p>

<p><strong>4) В чём разница между агрегированием и ассоциированием?</strong></p>

<p>Под агрегированием понимается владение (создание) объектом A объекта B. При этом допускается, что жизненный цикл объекта B не зависит от A.</p>

<p>Под ассоциированием понимается использование объектом A объекта B: объект A содержит ссылку или указатель на объект B и использует объект B, когда это необходимо.</p>

<p><strong>5) Как определить размер класса?</strong></p>

<p>Использовать конструкцию <strong>sizeof</strong> (имя класса) или <strong>sizeof</strong> (объект).</p>

<p><strong>6) Как реализовать функцию itoa?</strong></p>

<p>Вместо слов:</p>

<pre>
void itoa(int value, char *str)
{
    char *ptr = str;
    bool sign = value < 0;

    if (sign)
        value = -value;
    
    while (value)
    {
        char digit = value % 10;
        *ptr++ = '0' + digit;
        value /= 10;
    }

    if (sign)
        *ptr++ = '-';

    *ptr-- = '\0';

    while (str < ptr)
    {
        char symbol = *str;
        *str++ = *ptr;
        *ptr-- = symbol;
    }
}
</pre>


<p><strong>7) Как определить указатель на функцию?</strong></p>

<p><code>typedef void (*fn)(int, char *);</code></p>

<p><strong>8) Как связать программу, написанную на C++, с функциями, написанными на C?</strong></p>

<p>Объявление функций, написанных на C, нужно обернуть конструкцией вида <code>extern "C" { }</code>.</p>

<p><strong>9) Как вернуть структуру из функции?</strong></p>

<p>Обыкновенно, по значению (структура разместится в стеке).</p>

<p><strong>10) Как написать функцию, которая инвертирует связный список?</strong></p>

<p>Вариант 1. Перестановка значений. Двигаясь одновременно справа и слева к центру (до момента когда указатели встретятся) переставлять элементы. Минус - для этого нужно получить указатель на последний элемент (то есть обойти список).</p>

<p>Вариант 2. Перестановка указателей. Двигаясь в прямом направлении (слева направо): а) запоминаем указатель на текущий элемент и указатель на следующий элемент, б) у текущего элемента указателю на следующий элемент присваиваем значение указателя на предыдущий элемент, в) указателю на предыдущий элемент присваиваем адрес текущего элемента, г) переходим к следующему элементу по известному указателю (до тех пор пока он не NULL).</p>

<p><strong>11) Какие преимущества от использования исключений C++?</strong></p>

<p>С помощью исключений могут быть зафиксированы случаи некорректной работы программы (возникновение ошибок), приняты спасательные меры и сохранена работоспособность программы. Является альтернативой возврата кода ошибки. Имеет преимущество: исключение может быть поймано на любом уровне иерархии вызовов.</p>

<p><strong>12) Какая разница между структурой и классом в C++?</strong></p>

<p>Почти никакой. В структуре по умолчанию все члены являются публичными. В классе - приватными.</p>

<p><strong>13) Какие есть модификаторы элементов классов/структур и переменных?</strong></p>

<p>auto - обычный модификатор; является модификатором по умолчанию для локальных переменных функции.</p>

<p>register - модификатор, указывающий, что локальная переменная должна размещаться в регистре процессора, а не в памяти (стеке).</p>

<p>static - переменная существует на протяжении жизненного цикла программы (глобальная + ограничение области видимости).</p>

<p>extern - указание на глобальную переменную, которая где-то инициализирована и доступна всем частям программы.</p>

<p>mutable - только для членов класса; разрешает модификацию члена класса, даже если он объявлен в коде как константный.</p>

<p><strong>14) Что такое встроенные (inline) функции?</strong></p>

<p>Функции, которые не оформлены как самостоятельная единица. Тело таких функций копируется в то место программы, из которого осуществляется её &ldquo;вызов&rdquo;. Использование inline-функций даёт выигрыш в скорости исполнения (не происходит сохранение и восстановление слова-состояния процессора в стеке), но увеличивает размер программы.</p>

<p><strong>15) На что указывает ключевое слово extern в объявлении функции?</strong></p>

<p>На то, что функция определена в другом файле.</p>

<p><strong>16) -</strong></p>

<p><strong>17) Для чего используют ключевое слово static в объявлении функции?</strong></p>

<p>Ключевым словом static ограничивается область видимости функции (её нельзя вызвать из другого файла).
Если функция-член класса объявлена статической, то она может модифицировать только статичные члены класса.</p>

<p><strong>18) Что такое неявное преобразование типов в конструкторе?</strong></p>

<p>C++ допускает неявное преобразование аргумента Arg, указанного в конструкторе MyClass(int Arg) в объект MyClass. Для запрещения такого преобразования для конструктора необходимо указать ключевое слово explicit.</p>

<p><strong>19) Что такое конструктор копирования?</strong></p>

<p>Конструктор, который принимает единственный аргумент точно такого же типа как и сам объект. Предполагается, что создаваемый объект будет копией объекта, на который ссылается аргумент.</p>

<p><strong>20) Что такое пространство имён (namespace)?</strong></p>

<p>Средство разделения имён символов (функций, классов, переменных), служащее для исключения коллизий.</p>

<p><strong>21) Что такое абстрактная функция?</strong></p>

<p>Функция, которая должна быть обязательно определена в производном классе. Невозможно создать экземпляр базового класса, в котором объявлена абстрактная функция.</p>

<p><strong>22) Что такое оператор разрешения контекста?</strong></p>

<p><code>::</code> позволяет указать контекст класса, переменной, функции.</p>

<p><strong>23) Что такое абстракция?</strong></p>

<p>Средство для использования объектов без знания деталей реализации.</p>

<p><strong>24) В чём разница между #define и const.</strong></p>

<p><code>#define</code> является директивой препроцессора, которая служит для подстановки в код определённых с её помощью величин. Модификатор <code>const</code> позволяет один раз определить константную переменную и использовать её в тех местах программы, где это необходимо (по сравнению с <code>#define</code> это иногда сокращает размер программы).</p>

<p><strong>25) В чём разница между перегрузкой и переопределением метода?</strong></p>

<p>Перегрузка позволяет создать много методов с одним и тем же именем, но разным набором аргументов и возвращаемых значений. Это делается, в основном, для повышения читаемости кода.</p>

<p>Переопределение позволяет изменить поведение виртуальной функции у производного класса.</p>

    
    
  </article>
</section>


<section>
  <header>
    <time datetime="2015-08-09T09:57:15+03:00">09.08.2015</time>
    <h1><a href="/blog/2015/08/09/load-control-block-of-controller-for-hydroponics/">Блок управления внешней нагрузкой контроллера для гидропоники</a></h1>
  </header>
  <article>
    <p>Блок является частью <a href="/blog/2015/07/25/controller-for-hydroponics">контроллера</a> для гидропоники и выполняет управление четырьмя массивами светодиодов.</p>

<p><img src="/images/2015-08-09-load-control-block-of-controller-for-hydroponics/LedPower.png"></p>

<h3>Step-down преобразователь +30В -> +15В</h3>

<p>Преобразователь выполнен на базе <strong>LM2842</strong> (U1). Параметры преобразователя и порядок его настройки приводится в описании <a href="blog/2015/08/02/main-block-of-controller-for-hydroponics/">основного блока</a>.</p>

<p><strong>Расчёт:</strong></p>

<p>1) Входные данные: VIN = 30 В, VOUT = 15 В, IOUT = 0,5 А, Iripple = 0,15 А.</p>

<p>2) R1 = 1,5 кОм, R2 = (VOUT/0,765 – 1) * R1 = (15 / 0,765 – 1) * 1,5 = 28 кОм.</p>

<p>3) СIN = 10 мкФ (керамика).</p>

<p>4) L1 = (30 – 15) * 15 / (30 * 0,15 * 550 * 10<sup>3</sup>) = 91 мкГн (SDR1006-101KL).</p>

<p>5) COUT = 22 мкФ, Vripple=0,15 * (0,35 + [1 / (8 * 550 * 10<sup>3</sup> * 22 * 10<sup>-6</sup>)] = 0,053 В.</p>

<p>6) CBOOT = 1,0 мкФ.</p>

<p>7) D1 – 10BQ060 (60 В, 1,0 А).</p>

<h3>Преобразователь +15В -> +3,3В</h3>

<p>Преобразователь построен на базе микросхемы <strong>LM1117</strong>-N-3 (U2), характеризуемой максимальным током 800 мА.</p>

<p><strong>Расчёт:</strong></p>

<p>1) Входной конденсатор – 10 мкФ (тантал).</p>

<p>2) Выходной конденсатор – от 10 мкФ, рекомендуется 22 мкФ (тантал, ESR от 0,3 до 22 Ом).</p>

<h3>Измерение тока в цепи нагрузки</h3>

<p>Последовательно с нагрузкой соединён резистор номиналом 1 Ом (R29 - R32). Падение напряжения на этом резисторе пропорционально току, протекающему в цепи нагрузки. Это падение напряжения измеряется микроконтроллером <strong>STM32F031F</strong> (U3). Измеренное падение напряжения преобразуется микроконтроллером в периодический импульсный сигнал, имеющий фиксированную частоту 50 Гц и изменяемый коэффициент заполнения импульсов, пропорциональный падению напряжения. Этот периодический сигнал (F1-F4) поступает через транзистор (Q3-Q6) на оптопару HCPL053X (U10, U11) и далее в основной блок контроллера.</p>

<p>Прямой ток через диод оптопары HCPL053X составляет IF = (3,3 – VF)/R = (3,3 – 1,45) / 100 = 18,5 мА</p>

<p>Максимальный выходной ток оптопары при IF = 18,5 мА составляет примерно IO = 6 мА.</p>

<p>Для управления оптопарой выбран транзистор BC807 (коэффициент усиления по току – 100, не менее; в базе резистор 4,7 кОм, то есть базовый ток составляет (3,3 – 0,7)/4,7 = 0,55 мА, что позволяет получить ток коллектора от 50 мА и выше).</p>

<h3>Управление нагрузкой</h3>

<p>Управляющие сигналы на открытие силовых ключей поступают из основного блока контроллера на оптопары <strong>HCPL053X</strong> (U4, U7). Напряжение питания оптопар составляет +15 В.</p>

<p>Сигнал с коллектора оптопары поступает на инверсный вход драйвера n-канального MOSFET-транзистора (U5, U6 и U8, U9). В качестве драйвера используется микросхема IR2128S (с возможностью контроля КЗ; данная функция не используется). Драйвер также как и оптопара запитан от источника +15 В.</p>

<p>Сигнал с драйвера через резистор номиналом 100 Ом поступает на затвор силового n-канального транзистора IRF7341 (Q1, Q2). Силовой транзистор коммутирует напряжение +30 В на LC-фильтр нагрузки.</p>

<h3>Расчёт LC-фильтра нагрузки</h3>

<p>Расчёт происходит двумя способами, которые дают схожие результаты:</p>

<ul>
<li>способом, использованном для расчёта преобразователя +30В -> +15В;</li>
<li>способом, описанном в статье &ldquo;<em>Катушки индуктивности Bourns для преобразователей энергии</em>&rdquo;.</li>
</ul>


<p>Начальные данные: fsw = 10 кГц, VIN = 30 В, IOUT = 1 А. Выходное напряжение изменяется в диапазоне от 0 до 30 В.</p>

<p>Из статьи &ldquo;<em>Катушки индуктивности Bourns для преобразователей энергии</em>&rdquo;:</p>

<p>1) Период импульсов: Tsw = 1 / fsw = 100 мкс.</p>

<p>2) <strong>Средний</strong> коэффициент заполнения: D = (VOUTmax – VOUTmin) / 2VIN = (30 – 0) / (2 * 30) = 0,5.</p>

<p>3) Время открытия ключа Ton = DTsw = 50 мкс.</p>

<p>4) Величина пульсаций тока: Iripple = 0,3 * IOUT = 0,3 А.</p>

<p><em>Примечания</em></p>

<p>1 Величина пульсаций (и это важно) означает разницу между значением тока, протекающим через катушку в момент закрытия ключа, и значением тока, протекающим через катушку в момент открытия ключа. Другими словами, в момент открытия ключа ток, имеющий значение I1, начинает линейно расти до значения I1 + Iripple. В момент закрытия ключа ток начинает линейно уменьшаться (происходит заряд конденсатора COUT) до значения I1. С новым импульсом на открытие ключа цикл повторяется.</p>

<p>2 Из величины Iripple следует, что значение минимального стационарного тока составляет Is = Iripple/2 = 150 мА. Минимальный стационарный ток – это ток, который может быть передан дросселем в ёмкость COUT после закрытия ключа при заданном коэффициенте заполнения импульсов коммутации ключа. Если нагрузка требует меньший ток, то появятся автоколебания тока после закрытия ключа (ток потечёт в обратную сторону – в дроссель). Чтобы это исключить после дросселя устанавливается диод Шоттки.</p>

<p>5) Падение напряжения на катушке: V = VIN – (VOUTmax - VOUTmin) / 2 – Vdiode = 30 – 15 – 1 = 14 В.</p>

<p>6) Минимальное значение индуктивности: L2 = L3= L4 = L5 = VTon / Iripple = 2,333 мГн</p>

<p>7) COUT = C12 = C15 = C19 = C22 = 150 мкФ, ESR = 0,3 (танталовый). Пульсации напряжения для выбранного конденсатора составят: Vripple = Iripple(ESR + [1 / (8 * fsw * COUT)]) = 0,115 В.</p>

<p>Расчёт дросселя выполнялся в программе DrosselRing (1100):</p>

<p><img src="/images/2015-08-09-load-control-block-of-controller-for-hydroponics/LedL.png"></p>

    
    
  </article>
</section>


<section>
  <header>
    <time datetime="2015-08-02T09:42:35+03:00">02.08.2015</time>
    <h1><a href="/blog/2015/08/02/main-block-of-controller-for-hydroponics/">Основной блок контроллера для гидропоники</a></h1>
  </header>
  <article>
    <p>Основной блок является &ldquo;мозгами&rdquo; <a href="/blog/2015/07/25/controller-for-hydroponics">контроллера</a> для гидропоники.
Схема основного блока приводится на двух листах.</p>

<h2>Лист 1</h2>

<p><img src="/images/2015-08-02-main-block-of-controller-for-hydroponics/Main1.png"></p>

<h3>Step-down преобразователь +12В -> +3,3В</h3>

<p>Преобразователь построен на базе <strong>LM2842</strong> (U7). Его характеристики:</p>

<ul>
<li>частота переключений fsw = 550 кГц;</li>
<li>опорное напряжение VFB = 0,765 В;</li>
<li>входное напряжение VIN = 12 В.</li>
</ul>


<p><strong>Настройка (из тех. описания на LM2842):</strong></p>

<p>1) Величина выходного напряжения:
VOUT = VFB * (1 + R39/R38),
где R38 = 100..10000 Ом</p>

<p>2) Входной конденсатор С4 (керамика с низким ESR; X5R или X7R). Рекомендуемые значения ёмкости от 2,2 до 10 мкФ</p>

<p>3) Дроссель L1 = [(VIN - VOUT) * VOUT] / (VIN * Iripple * fsw)</p>

<p>С ростом допустимых пульсаций тока Iripple величина индуктивности уменьшается, но возрастают потери на намагничивание, потери в сердечнике. Это также требует выходного конденсатора большей ёмкости. Рекомендуемое значение Iripple составляет около 30% от величины выходного тока.
Расчёт индуктивности ведётся для максимального значения VIN.
КПД преобразователя напрямую зависит от сопротивления дросселя (лучшие показатели достигаются с использованием толстого провода). Рекомендуется использовать такой индуктор, в котором потери на нагрев составляют 2% от выходной мощности (другими словами, активное сопротивление дросселя составляет 2% от сопротивления нагрузки). Начальным вариантом является дроссель с индуктивностью от 10 до 22 мкГн и максимальным током 1,1 А или выше.</p>

<p>4) Выбор выходного конденсатора C6 зависит от величины максимальных допустимых пульсаций выходного напряжения. При постоянной частоте fsw величина пульсаций напряжения</p>

<p>Vripple = Iripple * (ESR + [1 / (8 * fsw * COUT)]).</p>

<p>Необходимо выбирать керамические конденсаторы с низким ESR. Рекомендуемый номинал от 22 до 100 мкФ с ESR ≤ 0,1 Ом.</p>

<p>5)   C5 ≥ 0,15 мкФ (керамика). Рекомендуется 1,0 мкФ.</p>

<p><strong>Расчёт:</strong></p>

<p>1) Входные данные: VIN = 12 В, VOUT = 3,3 В, IOUT = 0,5 А, Iripple = 0,15 А.</p>

<p>2) R38 = 1,4 кОм, R39 = (VOUT / 0,765 – 1) * R38 = (3,3 / 0,765 – 1) * 1,4 = 4,7 кОм.</p>

<p>3) С4 = 10 мкФ (керамика).</p>

<p>4) L1 = (12 – 3,3) * 3,3 / (12 * 0,15 * 550 * 10<sup>3</sup>) = 29 мкГн (SDR1006-330KL: 33 мкГн, Irms= 1,5 А).</p>

<p>5) C6 = 22 мкФ, Vripple = 0,15 * (0,35 + [1/(8 * 550 * 10<sup>3</sup> * 22 * 10<sup>-6</sup>)] = 0,053 В.</p>

<p>6) C5 = 1,0 мкФ.</p>

<p>7) D1 – 10BQ060 (60 В, 1,0 А).</p>

<h3>Аналоговая часть</h3>

<p>С целью уменьшения влияния цифровой части устройства на измеряемые аналоговые сигналы вводится «развязка» питания через LC-фильтр (по примеру схемы платы LPC1830-Xplorer).</p>

<p>Измерение аналоговых сигналов происходит с помощью резистивных делителей и операционных усилителей <strong>AD8606</strong> (питание +3,3 В) с коэффициентом усиления 1 (на схеме U3, U5).</p>

<p>Резистивный делитель построен на резисторах номиналами 10 и 3,3 кОм (R19 и R21, R26 и R27, R32 и R33) и позволяет измерять входное напряжение величиной до 13,3 В.</p>

<p>После делителя сигнал смещается вверх на 0,5 В (с помощью U3:A) и поступает на неинверсный вход операционного усилителя. С выхода операционного усилителя повторённый сигнал идёт на вход АЦП микроконтроллера.</p>

<h3>Дискретные сигналы</h3>

<p><strong>Входные сигналы типа &ldquo;сухой контакт&rdquo;</strong></p>

<p>Измерение входного дискретного сигнала типа «сухой контакт» (-, минус) осуществляется с помощью подтянутого к питанию +12 В резистора (номинал 10 кОм) и транзисторной сборки <strong>ULN2804</strong>, выбранной исходя из величины опорного напряжения (+12 В).</p>

<p>Коллектор выходного транзистора ULN2804 (U6) подтянут к питанию +3,3 В. Сигнал с коллектора поступает на сдвиговый регистр <strong>74HC165</strong> (U4), который по сигналу микроконтроллера преобразует входной параллельный код в выходной последовательный код и выдаёт микроконтроллеру состояние датчиков типа «сухой контакт».</p>

<p><strong>Выходные сигналы</strong></p>

<p>К выходным дискретным сигналам относятся: силовые напряжением ~220 В (ток до 5 А) и силовые напряжением +12 В (ток до 0,1 А).</p>

<p>Выдача дискретных сигналов происходит с помощью:</p>

<ul>
<li>сдвигового регистра <strong>74HC595</strong> (U1), в который микроконтроллер загружает слово (каждый бит слова определяет состояние выхода);</li>
<li>транзисторной сборки <strong>ULN2803</strong> (U2), которая выдаёт сигналы на реле (для коммутации напряжения ~220 В) и p-канальные транзисторы (для коммутации напряжения +12 В).</li>
</ul>


<p>Коммутацию напряжения ~220 В выполняет реле типа TRJ-12DC (RL1-RL4). В цепи фазы установлен предохранитель с номинальным током 5 А (FU1-FU4).</p>

<p>Коммутацию напряжения +12 В выполняет транзистор <strong>IRF7314</strong> (Q1). В цепи +12 В установлен самовосстанавливающийся защитный резистор с номинальным током 0,1 А (R4, R8).</p>

<h2>Лист 2</h2>

<p><img src="/images/2015-08-02-main-block-of-controller-for-hydroponics/Main2.png"></p>

<p>В центре схемы - микроконтроллер <strong>STM32F407Z</strong>. Он тактируется кварцевым резонатором частотой 12 МГц (X1 - HC-49SM, печатный монтаж), зашунтированным конденсаторами по 18 пФ (керамика).</p>

<p>Для питания микроконтроллера введён массив керамических конденсаторов номиналами 1,0 и 0,1 мкФ (C15-C22).</p>

<p>Отладка микроконтроллера происходит по интерфейсу JTAG. Для этого на плате размещается разъём XP1 (IDC-20MS).</p>

<h3>Диагностический интерфейс</h3>

<p>Для отладки устройства без использования специализированных средств (JTAG-программатора) служит выделенный USB-интерфейс, который построен на микросхеме <strong>CP2102</strong> (U10), представляющей собой полноценный преобразователь USB-UART.</p>

<p>Кроме стандартной обвязки CP2102 (рекомендации по её параметрам приводятся в описании к микросхеме) добавлен транзистор, который формирует сигнал RESET (сброс микроконтроллера). Дополнительный сигнал ISP нужен для ввода микроконтроллера в режим загрузчика.</p>

<p>Сигнал RESET определяется состоянием на линии DTR, сигнал ISP – состоянием на линии RTS. Сигнал сброса микроконтроллера RESET проходит через ФНЧ с постоянной времени τ = R77 * C13 = 47000 * 0,1 * 10-6 = 4,7 мс.</p>

<h3>Ethernet</h3>

<p>Схема модуля позаимствована из схемы платы LPC1830-Xplorer (OM13028).</p>

<p>Модуль построен на PHY <strong>LAN8720</strong> (U11). PHY тактируется от кварцевого генератора KXO-V97 частотой 50 МГц (самый крайний по приемлемости вариант, лучше использовать более точный генератор).</p>

<p>Особое внимание необходимо уделить питанию PHY. В цепи питания установлен LC-фильтр на базе L4 и C26-C28 (аналогично схеме-донору).</p>

<p>Сигнальный трансформатор встроен в разъём RJ-45 (XS1). В нём же установлены светодиоды, информирующие о скорости работы интерфейса и активности на линии.</p>

<h3>Часы реального времени</h3>

<p>Используется микросхема <strong>DS3231M</strong> (U13). Очень хороший вариант, рекомендую.</p>

<p>Часы могут работать как от основного питания, так от батарейки (в случае отсутствия основного питания). Взаимодействие микроконтроллера с часами происходит по интерфейсу I<sup>2</sup>C. Номиналы резисторов R87, R88 на линиях SDA и SCL определяют максимальную скорость информационного обмена. Установлены резисторы номиналом 10 кОм (при том, что имелся опыт работы на частоте 400 кГц с резисторами номиналом 22 кОм).</p>

<h3>Энергонезависимая память</h3>

<p>В качестве микросхемы энергонезависимой памяти используется <strong>AT45DB321D</strong> (U12) объёмом 4 Мбайт. Это довольно продвинутая память, которая берёт часть работы программиста на себя. Так, при записи новых данных, она копирует страницу во внутреннее ОЗУ, стирает страницу, а затем пишет в стёртую страницу результат слияния прошлых данных с теми, которые были переданы пользователем.</p>

<h3>Драйвер RS-485</h3>

<p>Для связи с периферийными устройствами по асинхронному последовательному каналу в контроллере находится драйвер шины RS-485 <strong>MAX-487</strong> (U9) с управлением потоком (чтение/запись).</p>

<h3>Схема токового управления нагрузкой</h3>

<p>Схема управления питанием основана на pnp-транзисторе (Q4-Q7), с помощью которого выдаётся сигнал на оптопару. Расчёт схемы проведён исходя из того, что на другой стороне установлены оптопары типа <strong>HCPL0530/&frac14;</strong>.</p>

<p>1) Прямой ток через диод оптопары составляет IF = (3,3 – VF) / R55 = (3,3 – 1,45) / 100 = 18,5 мА (VF - падение напряжения на диоде).</p>

<p>2) Максимальный выходной ток оптопары при IF = 18,5 мА составляет примерно IO = 6 мА.</p>

<p>3) Для управления оптопарой выбран транзистор <strong>BC807</strong> (коэффициент усиления по току – 100, не менее; в базе резистор 4,7 кОм, то есть базовый ток составляет (3,3 – 0,7) / 4,7 = 0,55 мА, что позволяет получить ток коллектора от 50 мА и выше).</p>

<p><strong>Измерения тока в цепи нагрузки</strong></p>

<p>Из схемы питания нагрузки в основной микроконтроллер через оптопару поступают импульсы (разъёмы XT17, XT18). Коллектор оптопары подтянут к питанию +3,3V через резистор номиналом 4,7 кОм (R60-R63).</p>

<h3>Подключение радиомодуля</h3>

<p>Предполагается, что в устройстве будет использован радиомодуль <strong>RF-2423P</strong>, работающий в области частоты 2,4 ГГц. Подключение радиомодуля осуществляется через разъём XP2 (PBD-8). Линия питания поддержана дополнительным танталовым конденсатором C11 ёмкостью 10 мкФ.</p>

    
    
  </article>
</section>


<section>
  <header>
    <time datetime="2015-07-26T08:38:40+03:00">26.07.2015</time>
    <h1><a href="/blog/2015/07/26/power-supply-of-controller-for-hydroponics/">Источник питания контроллера для гидропоники</a></h1>
  </header>
  <article>
    <p>В качестве источника питания для <a href="/blog/2015/07/25/controller-for-hydroponics">контроллера</a> используется импульсный блок на базе микросхемы IR2153.</p>

<p>Параметры источника питания:</p>

<ul>
<li>входное напряжение ~220 В &plusmn; 10 %, ток до 0,8 А;</li>
<li>выходное напряжение +30 В, ток 2 А;</li>
<li>выходное напряжение +12 В, ток 1 А.</li>
</ul>


<p>Схема блока питания:
<img src="/images/2015-07-26-power-supply-of-controller-for-hydroponics/PowerSource.png"></p>

<p>На входе источника находится <strong>фильтр</strong> ЭМП на базе дросселя TR1 индуктивностью 15 мГн (номинальный ток 0,8 А) и пары конденсаторов C1 и C2 номиналами 0,47 и 0,15 мкФ.</p>

<p>При включении источника в сеть ~220 В происходит ограничение тока с помощью NTC термистора номиналом 20 Ом. Также в цепи ~220 В установлен предохранитель, рассчитанный на максимальный ток 0,8 А.</p>

<p>Сетевое напряжение ~220 В выпрямляется с помощью диодного моста BR1 (DF06S). Выпрямленное пульсирующее напряжение (примем его за Uвыпр) заряжает конденсатор С3 ёмкостью 100 мкФ. Параллельно C3 подключён шунтирующий конденсатор C4 ёмкостью 1 мкФ.</p>

<p>Напряжение Uвыпр делится с помощью RC-делителя на базе конденсаторов C8, C9 ёмкостью 1 мкФ и резисторов R5, R6 номиналом 180 кОм. Это делается для того, чтобы на одном конце первичной обмотки трансформатора TR2 получить потенциал равный Uвыпр/2.</p>

<p>Коммутацией напряжения (вернее потенциала) Uвыпр на второй конец первичной обмотки трансформатора TR1 занимается <strong>драйвер</strong> U1 (IR2153) и управляемые им полевые n-канальные транзисторы Q1, Q2 (IRFR310).</p>

<p>Питание драйвера U1 получено из сетевого напряжения с помощью резистора R1 номиналом 18 кОм (мощностью 2 Вт!), диода D1 (FR107) и конденсатора C5 ёмкость 100 мкФ (полупериодный выпрямитель; внутри драйвера находится стабилитрон с обратным напряжением 15,6 В).</p>

<p>Частота коммутации драйвером U1 силовых транзисторов Q1, Q2 задаётся резистором R2 и конденсатором C6, имеющими номиналы соответственно 14 кОм и 1000 пФ. Из описания драйвера частота переключения:
fsw = 1/(1,38 * CT * (RT + 75)) = 1/(1,38 * 1000 * 10<sup>-12</sup> * 14075) = 51 кГц.</p>

<p>Первичная обмотка трансформатора TR2 зашунтирована последовательно включёнными конденсатором C10 ёмкостью 1000 пФ и резистором R7 сопротивлением 100 Ом для исключения передачи во вторичную обмотку высокочастотных помех.</p>

<p>В <strong>трансформаторе</strong> TR2 имеются две гальванически не связанные вторичные обмотки.
Параметры трансофрматора (тип и размер сердечника, количество витков) подбирались с помощью программы Lite-CalcIT (1700):</p>

<p><img src="/images/2015-07-26-power-supply-of-controller-for-hydroponics/TR2.png"></p>

<p>Одна из вторичных обмоток TR2 служит для получения однополярного питания +30 В. Напряжение вторичной обмотки выпрямляется с помощью диодного моста на базе диодов D3-D6 Шоттки 6CWQ10FN и сглаживается LC-фильтром. <strong>Параметры LC-фильтра</strong>:</p>

<ul>
<li>Начальные данные: входное напряжение VIN=60В, выходное напряжение VOUT=30В, частота переключений fsw = 50 кГц, выходной ток IOUT = 3 А, размах пульсаций тока в индуктивности Iripple = 1 А.</li>
<li>Расчёт:
L1 = (VIN-VOUT) * Ton/Iripple = (60 – 30) * 0,5 * (1/50000)/1 = 300 (330) мкГ.
Примем C11 = 220 мкФ (100 В, ESR = 0,6 Ом). Тогда пульсации напряжения на конденсаторе составят Vripple = Iripple * ESR = 0,6 В.</li>
</ul>


<p>Вторая обмотка трансформатора TR2 служит для получения однополярного питания +12 В. Аналогично предыдущему случаю, здесь используется диодный мост и LC-фильтр:</p>

<ul>
<li>Начальные данные: VIN=24 В, VOUT=12 В, fsw = 50 кГц, IOUT = 2 А, Iripple = 0,66 А.</li>
<li>Расчёт:
L = (VIN-VOUT) * Ton/Iripple = (24 – 12) * 0,5 * (1/50000)/0,66 = 181 (220) мкГ.
C = 220 мкФ (50В, ESR = 0,7 Ом). Vripple = Iripple * ESR = 0,7 В.</li>
</ul>


<p>Параметры <strong>дросселей</strong> L1 и L2 (тип и размер магнитопровода, количество витков) подбирались с помощью программы DrosselRing (1100).</p>

<p>L1:</p>

<p><img src="/images/2015-07-26-power-supply-of-controller-for-hydroponics/L1.png"></p>

<p>L2:</p>

<p><img src="/images/2015-07-26-power-supply-of-controller-for-hydroponics/L2.png"></p>

    
    
  </article>
</section>


<section>
  <header>
    <time datetime="2015-07-25T08:22:01+03:00">25.07.2015</time>
    <h1><a href="/blog/2015/07/25/controller-for-hydroponics/">Контроллер для гидропоники</a></h1>
  </header>
  <article>
    <p>В один прекрасный день я узнал о гидропонике. Это технология выращивания растений без использования грунта. Растение помещается в искусственную влажную и, вместе с тем, хорошо аэрируемую и обогащённую минералами среду. Это создаёт лучшие по сравнению с естественной средой условия для роста растения.</p>

<p>Детальное знакомство с гидропоникой показало, что для интенсификации роста растения (и повышения урожайности) нужно следить за множеством параметров создаваемой искусственной среды.</p>

<p>Среди таких параметров:</p>

<ul>
<li>температура воздуха;</li>
<li>влажность воздуха;</li>
<li>минеральный состав питательного раствора;</li>
<li>чистота минерального раствора и его pH;</li>
<li>интенсивность освещения и (что важно) его спектральный состав;</li>
<li>количество поступающего углекислого газа в часы бодрствования растения.</li>
</ul>


<p>Очевидно, что обеспечить соблюдение всех параметров в ручном режиме является трудно осуществимой задачей. Необходимы технические средства для автоматизации процесса выращивания растений.</p>

<p>Такая необходимость и желание опробовать свои знания в области электроники привели к тому, что появился проект выходного дня под условным названием &ldquo;Контроллер для гидропоники&rdquo;.</p>

<p>Контроллер обладает следующими характеристиками:</p>

<ul>
<li>4 реле, коммутирующие напряжение ~220 В (ток до 5 А);</li>
<li>4 дискретных входа типа &ldquo;сухой контакт&rdquo;;</li>
<li>2 выхода +12 В (ток до 100 мА);</li>
<li>3 аналоговых входа для измерения сигнала напряжением от 0 до +10 В;</li>
<li>часы реального времени;</li>
<li>встроенная память объемом 4 Мбайт;</li>
<li>сервисный USB-интерфейс (виртуальный COM-порт);</li>
<li>последовательный интерфейс RS-485 для связи с внешними датчиками или исполнительными механизмами;</li>
<li>возможность подключения к сети Ethernet для настройки режимов работы;</li>
<li>4 выхода питания внешней нагрузки с токовым управлением (напряжение до +30 В, ток до 0,9 А);</li>
<li>встроенный импульсный источник питания.</li>
</ul>


<p>Используемые микроконтроллеры:</p>

<ul>
<li>STM32F407Z - выполнение программы управления;</li>
<li>STM32F031F - для оцифровки токов в цепях питания внешней нагрузки.</li>
</ul>


<p>Контроллер состоит из следующих блоков:</p>

<ul>
<li><a href="/blog/2015/07/26/power-supply-of-controller-for-hydroponics">источник питания</a>;</li>
<li><a href="/blog/2015/08/02/main-block-of-controller-for-hydroponics">основной блок</a>;</li>
<li><a href="/blog/2015/08/09/load-control-block-of-controller-for-hydroponics">блок управления внешней нагрузкой</a>.</li>
</ul>


    
    
  </article>
</section>

<nav>
  
    <span class="pagination-item">Вперёд в прошлое</span>
  
  
    <span class="pagination-item">Назад в будущее</span>
  
</nav>
    <footer>
  Копилефт <!--[if lte IE 8]><span style="filter: FlipH; -ms-filter: "FlipH"; display: inline-block;"><![endif]--><span style="-moz-transform: scaleX(-1); -o-transform: scaleX(-1); -webkit-transform: scaleX(-1); transform: scaleX(-1); display: inline-block;">©</span><!--[if lte IE 8]></span><![endif]--> 2017 — Пименов Михаил
  <address>
  </address>
</footer>
  </body>
</html>