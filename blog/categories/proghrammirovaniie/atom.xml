<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Category: программирование | scon.pro]]></title>
  <link href="http://mupimenov.github.io/blog/categories/proghrammirovaniie/atom.xml" rel="self"/>
  <link href="http://mupimenov.github.io/"/>
  <updated>2017-01-28T16:44:26+03:00</updated>
  <id>http://mupimenov.github.io/</id>
  <author>
    <name><![CDATA[Пименов Михаил]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Вопросы по C++ (часть 2)]]></title>
    <link href="http://mupimenov.github.io/blog/2016/05/16/c-plus-plus-questions-part-2/"/>
    <updated>2016-05-16T10:11:08+03:00</updated>
    <id>http://mupimenov.github.io/blog/2016/05/16/c-plus-plus-questions-part-2</id>
    <content type="html"><![CDATA[<p>Вторая часть ответов на <a href="http://www.mycplus.com/featured-articles/50-c-plus-plus-interview-questions/">интервью-вопросы</a> на знание языка программирования C++.</p>

<p><strong>26) Что такое инкапсуляция</strong></p>

<p>Инкапсуляцией называют скрытие деталей реализации внутри класса. При использовании механизма инкапсуляции объекты защищаются от произвольного изменения (с помощью ключевых слов protected или private); взаимодействие с объектом происходит с помощью публичных функций-членов.</p>

<p><strong>27) Что такое перегрузка функций?</strong></p>

<p>С помощью перегрузки имеется возможность определять функции, имеющие одно и то же имя, но разный набор аргументов и/или возвращающие разные результаты.</p>

<p><strong>28) Что такое множественное наследование?</strong></p>

<p>Множественное наследование позволяет определить производный класс, который будет наследовать члены от нескольких базовых классов.</p>

<p><strong>29) Что такое перегрузка операторов?</strong></p>

<p>Аналогично перегрузке функций это возможность ЯП определить поведение оператора, при передаче ему разных аргументов.</p>

<p><strong>30) Что такое частичная специализация шаблона?</strong></p>

<p>Частичная специализация шаблона позволяет явно задать параметры основного шаблона и доопределить полученный шаблон в соответствие с его назначением.</p>

<p><strong>31) Что такое полиморфизм?</strong></p>

<p>Свойство языка, позволяющая определить разное поведение для объектов с одинаковой спецификацией.</p>

<p>Пример 1: производный класс наследует публичный интерфейс базового класса, но с помощью перекрытия изменяет поведение виртуальных функций.</p>

<p>Пример 2: перегрузка функций.</p>

<p><strong>32) В чём разница между передачей аргумента по значению и передачей аргумента по ссылке?</strong></p>

<p>В способе размещения аргумента в памяти. При передаче аргумента по значение он копируется в стек, а вызываемая функция работает с копией аргумента.
При передаче аргумента по ссылке вызываемая функция работает с исходным аргументом, а не его копией (ссылка является псевдонимом переменной).</p>

<p><strong>33) Какая разница между объектом и классом?</strong></p>

<p>Класс является сложным типом, который описывает внутренние данные и функциональный интерфейс. Объект является экземпляром класса, размещаемым в памяти.</p>

<p><strong>34) В чём разница между объявлением и определением функции?</strong></p>

<p>В объявлении указывается формат вызова, в который входят 1) имя функции, 2) описание аргументов, передаваемых в функцию, и 3) описание возвращаемого функцией результата.
В определении реализуется алгоритм работы функции.</p>

<p><strong>35) -</strong></p>

<p><strong>36) В чём разница между delete и delete[]?</strong></p>

<p>Ключевое слово delete используется для удаления объекта, которое происходит в два этапа. Во-первых, вызывается деструктор объекта, который, например, выполняет удаление членов класса. Во-вторых, выполняется освобождение занимаемой объектом памяти.
Ключевое слово delete[] используется для удаления массива объектов, при этом для каждого элемента массива будет вызван деструктор, а затем произойдёт освобождение памяти.</p>

<p><strong>37) Какая разница между вложенным (внутренним) классом и абстрактным классом?</strong></p>

<p>Внутренний класс - это класс, который определён внутри другого класса.
Абстрактный класс - это класс, имеющий чисто виртуальные функции-члены.</p>

<p><strong>38) В чём разница между перманентным и неперманентным объектом?</strong></p>

<p>Перманентный объект сохраняет своё состояние на всём протяжении жизни, в то время как неперманентный объект может изменить своё состояние.</p>

<p><strong>39) Чем отличается структура (struct) от объединения (union)?</strong></p>

<p>Объединение отличается от структуры способом размещения данных-членов. В объединении данные-члены делят отводимую для них область памяти так, что перекрывают друг друга.
В структуре (равно как и в классе) данные-члены размещаются в своих областях памяти.</p>

<p><strong>40) Чем отличается поверхностное копирование от глубокого копирования?</strong></p>

<p>При поверхностном копировании будет, например, продублирован указатель на данные (появится новый объект, который ссылается на существующие данные). При глубоком копировании вместо сохранения указателя будет осуществляться полное копирование данных.</p>

<p><strong>41) Какая разница между открытыми, защищёнными и закрытыми членами класса?</strong></p>

<p>Разница заключается в уровнях доступа к этим членам.
Открытые члены класса доступны всем. Защищённые доступны только данному классу и классам-наследникам. Закрытые члены доступны только данному классу.</p>

<p><strong>42) Какую максимальную длину может иметь массив?</strong></p>

<p>Это зависит от нескольких факторов. Во-первых, от способа размещения массива. При размещении на стеке размер зависит от размера стека (и его способности к расширению). При размещении в куче - от возможностей аппаратных средств и ОС. Во-вторых, размер должен укладываться в size_t, который зависит от используемой платформы (32 или 64 разряда).</p>

<p><strong>43) Как наиболее эффективно инвертировать связный список?</strong></p>

<p>Перейти в конец списка и двигаясь к началу менять местами указатели на следующий и предыдущий элементы списка.</p>

<p><strong>44) Какой размер у пустого класса?</strong></p>

<p>Размер пустого класса должен по крайней мере быть равен размеру минимально адресуемой области памяти. Обычно это 1 байт.</p>

<p><strong>45) Зачем используется виртуальный деструктор?</strong></p>

<p>Это единственный способ обеспечить вызов деструктора у производного класса при удалении объекта по указателю на базовый класс.</p>

<p><strong>46) Что такое виртуальный класс? Что такое дружественный класс?</strong></p>

<p>Виртуальный класс - это класс, имеющий виртуальные функции-члены.
Дружественный класс - это класс, который имеет доступ к закрытым членам данного класса.</p>

<p><strong>47. Назовите лучший способ объявить и определить глобальную переменную.</strong>
Вариант 1 (C-style):</p>

<pre>
// source.c
int global = 0;
// source.h
extern int global;
</pre>


<p>Вариант 2 (С++ style): определить класс с открытой статической переменной:</p>

<pre>
// source.hpp
class A {public: static int global;};
// source.cpp
int A::global = 0;
</pre>


<p><strong>48) В какой области памяти инстанцируется объект?</strong></p>

<p>Зависит от способа размещения. Если объект является локальной переменной, то он размещается в стеке. Если объект создаётся с использованием ключевого слова new, то он размещается в куче.</p>

<p><strong>49) В какой области памяти инстанцируется структура?</strong></p>

<p>Аналогично объекту (см. ответ на вопрос 48).</p>

<p><strong>50) Почему первый элемент массива имеет индекс 0?</strong></p>

<p>Индекс массива определяет смещение относительно начала массива. Очевидно, что по смещению 0 находится первый элемент.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Вопросы по С++ (часть 1)]]></title>
    <link href="http://mupimenov.github.io/blog/2015/08/16/c-plus-plus-questions-part-1/"/>
    <updated>2015-08-16T10:09:18+03:00</updated>
    <id>http://mupimenov.github.io/blog/2015/08/16/c-plus-plus-questions-part-1</id>
    <content type="html"><![CDATA[<p>Первая часть моих ответов на вопросы из <a href="http://www.mycplus.com/featured-articles/50-c-plus-plus-interview-questions/">списка</a>.</p>

<p><strong>1) Как определить, что связный список является кольцевым?</strong></p>

<p>Запомнить указатель (итератор) на первый элемент списка. Начать обход списка от первого элемента к последнему. Если в процессе обхода текущий указатель равен указателю на первый элемент списка, то список кольцевой. Если список пройден - список не является кольцевым.</p>

<p><strong>2) Какой целочисленный тип использовать?</strong></p>

<p>Это определяется прикладной задачей, решаемой в рамках данной предметной области. Во-первых, нужно определиться с шириной коридора принимаемых значений переменной целочисленного типа (char, short, int, long, long long; с использованием модификаторов signed, unsigned). Во-вторых, учесть количество памяти, отводимое под переменную соответствующего типа (1, 2, 4 или 8 байт).</p>

<p><strong>3) Каково отличие между конструктором и деструктором.</strong></p>

<p>Конструктор - специальный метод объекта, вызываемый сразу после выделения ему памяти, выполняющий инициализацию членов объекта. Деструктор - метод вызываемый перед освобождением памяти, отводимой объекту, служащий для &ldquo;деинициализации&rdquo; (например, удаления) членов объекта.</p>

<p><strong>4) В чём разница между агрегированием и ассоциированием?</strong></p>

<p>Под агрегированием понимается владение (создание) объектом A объекта B. При этом допускается, что жизненный цикл объекта B не зависит от A.</p>

<p>Под ассоциированием понимается использование объектом A объекта B: объект A содержит ссылку или указатель на объект B и использует объект B, когда это необходимо.</p>

<p><strong>5) Как определить размер класса?</strong></p>

<p>Использовать конструкцию <strong>sizeof</strong> (имя класса) или <strong>sizeof</strong> (объект).</p>

<p><strong>6) Как реализовать функцию itoa?</strong></p>

<p>Вместо слов:</p>

<pre>
void itoa(int value, char *str)
{
    char *ptr = str;
    bool sign = value < 0;

    if (sign)
        value = -value;
    
    while (value)
    {
        char digit = value % 10;
        *ptr++ = '0' + digit;
        value /= 10;
    }

    if (sign)
        *ptr++ = '-';

    *ptr-- = '\0';

    while (str < ptr)
    {
        char symbol = *str;
        *str++ = *ptr;
        *ptr-- = symbol;
    }
}
</pre>


<p><strong>7) Как определить указатель на функцию?</strong></p>

<p><code>typedef void (*fn)(int, char *);</code></p>

<p><strong>8) Как связать программу, написанную на C++, с функциями, написанными на C?</strong></p>

<p>Объявление функций, написанных на C, нужно обернуть конструкцией вида <code>extern "C" { }</code>.</p>

<p><strong>9) Как вернуть структуру из функции?</strong></p>

<p>Обыкновенно, по значению (структура разместится в стеке).</p>

<p><strong>10) Как написать функцию, которая инвертирует связный список?</strong></p>

<p>Вариант 1. Перестановка значений. Двигаясь одновременно справа и слева к центру (до момента когда указатели встретятся) переставлять элементы. Минус - для этого нужно получить указатель на последний элемент (то есть обойти список).</p>

<p>Вариант 2. Перестановка указателей. Двигаясь в прямом направлении (слева направо): а) запоминаем указатель на текущий элемент и указатель на следующий элемент, б) у текущего элемента указателю на следующий элемент присваиваем значение указателя на предыдущий элемент, в) указателю на предыдущий элемент присваиваем адрес текущего элемента, г) переходим к следующему элементу по известному указателю (до тех пор пока он не NULL).</p>

<p><strong>11) Какие преимущества от использования исключений C++?</strong></p>

<p>С помощью исключений могут быть зафиксированы случаи некорректной работы программы (возникновение ошибок), приняты спасательные меры и сохранена работоспособность программы. Является альтернативой возврата кода ошибки. Имеет преимущество: исключение может быть поймано на любом уровне иерархии вызовов.</p>

<p><strong>12) Какая разница между структурой и классом в C++?</strong></p>

<p>Почти никакой. В структуре по умолчанию все члены являются публичными. В классе - приватными.</p>

<p><strong>13) Какие есть модификаторы элементов классов/структур и переменных?</strong></p>

<p>auto - обычный модификатор; является модификатором по умолчанию для локальных переменных функции.</p>

<p>register - модификатор, указывающий, что локальная переменная должна размещаться в регистре процессора, а не в памяти (стеке).</p>

<p>static - переменная существует на протяжении жизненного цикла программы (глобальная + ограничение области видимости).</p>

<p>extern - указание на глобальную переменную, которая где-то инициализирована и доступна всем частям программы.</p>

<p>mutable - только для членов класса; разрешает модификацию члена класса, даже если он объявлен в коде как константный.</p>

<p><strong>14) Что такое встроенные (inline) функции?</strong></p>

<p>Функции, которые не оформлены как самостоятельная единица. Тело таких функций копируется в то место программы, из которого осуществляется её &ldquo;вызов&rdquo;. Использование inline-функций даёт выигрыш в скорости исполнения (не происходит сохранение и восстановление слова-состояния процессора в стеке), но увеличивает размер программы.</p>

<p><strong>15) На что указывает ключевое слово extern в объявлении функции?</strong></p>

<p>На то, что функция определена в другом файле.</p>

<p><strong>16) -</strong></p>

<p><strong>17) Для чего используют ключевое слово static в объявлении функции?</strong></p>

<p>Ключевым словом static ограничивается область видимости функции (её нельзя вызвать из другого файла).
Если функция-член класса объявлена статической, то она может модифицировать только статичные члены класса.</p>

<p><strong>18) Что такое неявное преобразование типов в конструкторе?</strong></p>

<p>C++ допускает неявное преобразование аргумента Arg, указанного в конструкторе MyClass(int Arg) в объект MyClass. Для запрещения такого преобразования для конструктора необходимо указать ключевое слово explicit.</p>

<p><strong>19) Что такое конструктор копирования?</strong></p>

<p>Конструктор, который принимает единственный аргумент точно такого же типа как и сам объект. Предполагается, что создаваемый объект будет копией объекта, на который ссылается аргумент.</p>

<p><strong>20) Что такое пространство имён (namespace)?</strong></p>

<p>Средство разделения имён символов (функций, классов, переменных), служащее для исключения коллизий.</p>

<p><strong>21) Что такое абстрактная функция?</strong></p>

<p>Функция, которая должна быть обязательно определена в производном классе. Невозможно создать экземпляр базового класса, в котором объявлена абстрактная функция.</p>

<p><strong>22) Что такое оператор разрешения контекста?</strong></p>

<p><code>::</code> позволяет указать контекст класса, переменной, функции.</p>

<p><strong>23) Что такое абстракция?</strong></p>

<p>Средство для использования объектов без знания деталей реализации.</p>

<p><strong>24) В чём разница между #define и const.</strong></p>

<p><code>#define</code> является директивой препроцессора, которая служит для подстановки в код определённых с её помощью величин. Модификатор <code>const</code> позволяет один раз определить константную переменную и использовать её в тех местах программы, где это необходимо (по сравнению с <code>#define</code> это иногда сокращает размер программы).</p>

<p><strong>25) В чём разница между перегрузкой и переопределением метода?</strong></p>

<p>Перегрузка позволяет создать много методов с одним и тем же именем, но разным набором аргументов и возвращаемых значений. Это делается, в основном, для повышения читаемости кода.</p>

<p>Переопределение позволяет изменить поведение виртуальной функции у производного класса.</p>
]]></content>
  </entry>
  
</feed>